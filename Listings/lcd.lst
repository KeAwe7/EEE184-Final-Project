C51 COMPILER V9.60.7.0   LCD                                                               05/19/2024 09:56:49 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LCD
OBJECT MODULE PLACED IN .\Objects\lcd.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE lcd.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\lcd.l
                    -st) TABS(2) OBJECT(.\Objects\lcd.obj)

line level    source

   1          #include "lcd.h"  // Include header file for LCD functions
   2          
   3          // Function: Lcd1602_Delay1ms
   4          // Description: Creates a delay of approximately 1 millisecond.
   5          // Input: c (Number of times to repeat the delay loop)
   6          // Output: None
   7          void Lcd1602_Delay1ms(uint c) { 
   8   1          uchar a, b;   // Declare loop counters
   9   1          for (; c > 0; c--) {   // Outer loop: Repeat 'c' times
  10   2              for (b = 199; b > 0; b--) {  // Middle loop: Repeat 199 times
  11   3                  for (a = 1; a > 0; a--);  // Inner loop: Execute once (for fine-tuning delay)
  12   3              }
  13   2          }
  14   1      }
  15          
  16          // Function: LcdWriteCom
  17          // Description: Writes a command byte to the LCD1602.
  18          // Input: com (The command byte to send)
  19          // Output: None
  20          #ifndef LCD1602_4PINS  // If NOT in 4-bit mode (i.e., 8-bit mode)
              void LcdWriteCom(uchar com) {
                  LCD1602_E = 0;      // Pull enable (E) pin low
                  LCD1602_RS = 0;     // Set register select (RS) for command (0)
                  LCD1602_RW = 0;     // Set read/write (RW) for write (0)
              
                  LCD1602_DATAPINS = com;    // Send the command byte on the data pins
                  Lcd1602_Delay1ms(1);       // Short delay for data setup time
              
                  LCD1602_E = 1;      // Pulse the enable (E) pin high to initiate write
                  Lcd1602_Delay1ms(5);       // Hold E high for a sufficient time
                  LCD1602_E = 0;      // Pull E low to complete the write
              }
              #else  // If in 4-bit mode
  34          void LcdWriteCom(uchar com) {
  35   1          LCD1602_E = 0;      // Pull E low
  36   1          LCD1602_RS = 0;     // Select command mode
  37   1          LCD1602_RW = 0;     // Select write mode
  38   1      
  39   1          LCD1602_DATAPINS = com;    // Send high nibble of the command (doesn't need shifting)
  40   1          Lcd1602_Delay1ms(1);       // Short delay
  41   1      
  42   1          LCD1602_E = 1;      // Pulse E high to write high nibble
  43   1          Lcd1602_Delay1ms(5);       // Hold E high
  44   1          LCD1602_E = 0;      // Pull E low
  45   1      
  46   1          LCD1602_DATAPINS = com << 4; // Shift low nibble of the command to high nibble position
  47   1          Lcd1602_Delay1ms(1);       // Short delay
  48   1      
  49   1          LCD1602_E = 1;      // Pulse E high to write low nibble
  50   1          Lcd1602_Delay1ms(5);       // Hold E high
  51   1          LCD1602_E = 0;      // Pull E low
  52   1      }
  53          #endif 
  54          
C51 COMPILER V9.60.7.0   LCD                                                               05/19/2024 09:56:49 PAGE 2   

  55          
  56          // Function: LcdWriteData
  57          // Description: Writes a data byte to the LCD1602.
  58          // Input: dat (The data byte to send)
  59          // Output: None
  60          #ifndef LCD1602_4PINS  // If NOT in 4-bit mode (i.e., 8-bit mode)
              void LcdWriteData(uchar dat) { 
                  LCD1602_E = 0;      // Pull E low
                  LCD1602_RS = 1;     // Set RS for data (1)
                  LCD1602_RW = 0;     // Set RW for write (0)
                  
                  LCD1602_DATAPINS = dat;    // Send the data byte
                  Lcd1602_Delay1ms(1);       // Short delay
              
                  LCD1602_E = 1;      // Pulse E high to initiate write
                  Lcd1602_Delay1ms(5);       // Hold E high
                  LCD1602_E = 0;      // Pull E low
              }
              #else // If in 4-bit mode
  74          void LcdWriteData(uchar dat) {
  75   1         // Same as LcdWriteCom, but with LCD1602_RS = 1 (data mode) 
  76   1         // (code omitted for brevity, since it's identical to LcdWriteCom's 4-bit mode)
  77   1          LCD1602_E = 0;      // Pull E low
  78   1          LCD1602_RS = 1;     // Select command mode
  79   1          LCD1602_RW = 0;     // Select write mode
  80   1      
  81   1          LCD1602_DATAPINS = dat;    // Send high nibble of the command (doesn't need shifting)
  82   1          Lcd1602_Delay1ms(1);       // Short delay
  83   1      
  84   1          LCD1602_E = 1;      // Pulse E high to write high nibble
  85   1          Lcd1602_Delay1ms(5);       // Hold E high
  86   1          LCD1602_E = 0;      // Pull E low
  87   1      
  88   1          LCD1602_DATAPINS = dat << 4; // Shift low nibble of the command to high nibble position
  89   1          Lcd1602_Delay1ms(1);       // Short delay
  90   1      
  91   1          LCD1602_E = 1;      // Pulse E high to write low nibble
  92   1          Lcd1602_Delay1ms(5);       // Hold E high
  93   1          LCD1602_E = 0;      // Pull E low
  94   1      }
  95          #endif
  96          
  97          // Function: LcdInit
  98          // Description: Initializes the LCD1602.
  99          // Input: None
 100          // Output: None
 101          #ifndef LCD1602_4PINS  // If NOT in 4-bit mode (i.e., 8-bit mode)
              void LcdInit() {
                  LcdWriteCom(0x38);  // Function Set: 8-bit, 2 lines, 5x8 font
                  LcdWriteCom(0x0F);  // Display on, cursor on, blink on
                  LcdWriteCom(0x06);  // Entry Mode Set: Increment cursor, no shift
                  LcdWriteCom(0x01);  // Clear display
                  LcdWriteCom(0x80);  // Set DDRAM address to 0x00 (start of first line)
              }
              #else  // If in 4-bit mode
 110          void LcdInit() {
 111   1          LcdWriteCom(0x32);  // Special 4-bit mode initialization
 112   1          LcdWriteCom(0x28);  // Function Set: 4-bit, 2 lines, 5x8 font
 113   1          LcdWriteCom(0x0F);  // Display on, cursor on, blink on
 114   1          LcdWriteCom(0x06);  // Entry Mode Set: Increment cursor, no shift
 115   1          LcdWriteCom(0x01);  // Clear display
 116   1          LcdWriteCom(0x80);  // Set DDRAM address to 0x00 (start of first line)
C51 COMPILER V9.60.7.0   LCD                                                               05/19/2024 09:56:49 PAGE 3   

 117   1      }
 118          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    120    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
